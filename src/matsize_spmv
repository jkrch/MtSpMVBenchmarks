#!/bin/bash
#
# In julia benchmark different SpMV kernels for an increasing number of threads.


# Command line arguments 
julia=$1
nthreads=$2
N=$3
nnzrow=$4
kernels=$5 
matrices=$6

# Convert argument strings to arrays
IFS=' ' read -ra nthreads <<< "$nthreads"
IFS=' ' read -ra kernels <<< "$kernels"
IFS=' ' read -ra matrices <<< "$matrices"

# Create result folder
h=$(hostname)
d=$(date +%Y-%m-%d)
t=$(date +%H-%M-%S)
header="${h}__${d}__${t}"
echo $header
folder="matsize/spmv/${header}"
mkdir -p $folder

# Filepath for benchmark description
labels="${folder}/labels.txt"


#######################################
# Run benchmarks in julia.
# Globals:
#   N
#   result
#   labels
#   julia
#   jlfile
#   nnzrow
#   kernel
# Arguments:
#   None
# Outputs:
#   Writes results to csv and txt file
#######################################
function runbenchmarks() {
	printf "matsize = "
	# Write header to csv file
	echo "matsize  seconds" >> $result
	# Run benchmarks for increasing size of matrix and write results to csv
	for ((i=1; i<=N ; i++)); do 
		n=$((10**$i))
		printf "10e%d.." $i
		printf "%d" $n >> $result
		$julia nthreads_run.jl spmv $kernel $matrix $n $n $nnzrow >> $result
	done
	echo
	# # Copy results to txt file
	# cat $result >> $labels
	# echo >> $labels
}


function contains() {
    local n=$#
    local value=${!n}
    for ((i=1;i < $#;i++)) {
        if [ "${!i}" == "${value}" ]; then
            echo "y"
            return 0
        fi
    }
    echo "n"
    return 1
}


# Benchmark serial CSR MatVec from SparseArrays.jl
if [ $(contains "${kernels[@]}" "ser") == "y" ] && 
[ $(contains "${matrices[@]}" "csr") == "y" ]; then
	echo "SparseArrays.jl CSR, 1 thread(s)"
	echo "SparseArrays.jl CSC, 1 thread(s)" >> $labels
	kernel=ser
	matrix=csr
	result="${folder}/result_${kernel}_${matrix}_1.csv"
	export MKL_NUM_THREADS=1
	export JULIA_NUM_THREADS=1
	runbenchmarks
	echo >> $labels
fi


# Benchmark serial CSC MatVec from SparseArrays.jl
if [ $(contains "${kernels[@]}" "ser") == "y" ] && 
[ $(contains "${matrices[@]}" "csc") == "y" ]; then
	echo "SparseArrays.jl CSC, 1 thread(s)"
	echo "SparseArrays.jl CSC, 1 thread(s)" >> $labels
	kernel=ser
	matrix=csc
	result="${folder}/result_${kernel}_${matrix}_1.csv"
	export MKL_NUM_THREADS=1
	export JULIA_NUM_THREADS=1
	runbenchmarks
	echo >> $labels
fi


# Benchmark multithreaded CSR MatVec from MtSpMV.jl
if [ $(contains "${kernels[@]}" "par") == "y" ] && 
[ $(contains "${matrices[@]}" "csr") == "y" ]; then
	for t in "${nthreads[@]}"
	do
		echo "MtSpMV.jl CSR, $t thread(s)"
		echo "MtSpMV.jl CSR, $t thread(s)" >> $labels
		kernel=par
		matrix=csr
		result="${folder}/result_${kernel}_${matrix}_$t.csv"
		export MKL_NUM_THREADS=1
		export JULIA_NUM_THREADS=$t
		runbenchmarks
	done
	echo >> $labels
fi


# Benchmark multithreaded CSR MatVec from MKLSparse.jl
if [ $(contains "${kernels[@]}" "mkl") == "y" ] && 
[ $(contains "${matrices[@]}" "csr") == "y" ]; then
	for t in "${nthreads[@]}"
	do
	    echo "MKLSparse.jl CSR, $t thread(s)"
	    echo "MKLSparse.jl CSR, $t thread(s)" >> $labels
	    kernel=mkl
	    matrix=csr
	    result="${folder}/result_${kernel}_${matrix}_$t.csv"
	    export MKL_NUM_THREADS=$t
	    export JULIA_NUM_THREADS=1
	    runbenchmarks
	done
	echo >> $labels
fi


# Benchmark multithreaded CSC MatVec from MKLSparse.jl
if [ $(contains "${kernels[@]}" "mkl") == "y" ] && 
[ $(contains "${matrices[@]}" "csc") == "y" ]; then
	for t in "${nthreads[@]}"
	do
	    echo "MKLSparse.jl CSC, $t thread(s)"
	    echo "MKLSparse.jl CSC, $t thread(s)" >> $labels
	    kernel=mkl
	    matrix=csc
	    result="${folder}/result_${kernel}_${matrix}_$t.csv"
	    export MKL_NUM_THREADS=$t
	    export JULIA_NUM_THREADS=1
	    runbenchmarks
	done
	echo >> $labels
fi


# Plot results
echo "Plotting.."
# $julia plot.jl matsize "spmv/${folder}"

